# 쿠버네티스 프로젝트를 하며 경험한 것 느낀 것을 정리한다.

## 마스터 노드 관리
```
AWS- EKS를 사용하면 마스터 노드를 관리할 필요성이 없다.

쿠버네티스는 매우 활발한 오픈소스이기 때문에 버전 업그레이드가 잦은데,
버전이 업데이트가 되면 마스터 노드 및 워커노드를 drain & cordon 하면서
버전 업그레이드를 시켜줘야 한다. 

하지만, 매니지드 쿠버네티스를 사용하면 사용자는 마스터노드를 신경 쓸 필요가 없고
클릭 한번으로 버전 업그레이드가 가능하다.
```

## Pending 상태
```
클러스터 내 애플리케이션을 taint나 node affinity , nodename 등으로
스케줄링하지 않는다면 자유롭게 이동하기 때문에 워커노드1을 drain시키는 동안
워커노드1에 있는 애플리케이션은 다른 워커 노드로 이동한다.
그렇게 이동함으로써, 애플리케이션은 정상적으로 동작한다.

노드에 애플리케이션을 할당하는 것은 쿠버네티스 스케줄러이다.
특별한 제약을 걸지 않았다면 각 노드의 리소스 사용량에 따라 애플리케이션을
노드에 할당한다. 

만약 클라우드에서 매니지드 쿠버네티스를 사용하는 데, 워커 노드가 2개로
A, B가 있다고 하자.
각 노드마다 할당된 애플리케이션이 20개가 있다고 해보자.
그리고 그 노드는 AWS EC2 t3.small 이라는 인스턴스를 사용한다.

AWS EC2 오토 스케일링 기능을 통해, 워커노드의 개수를 2 -> 1로 바꾸면 
어떻게 될까 ?

사라지는 노드가 A라면 A 안에 있는 애플리케이션은 노드 B로 이동하려고 할 것이다.
그러나 t3.small이 할당가능한 애플리케이션 개수가 10개라면, 노드 A 안에 있는
애플리케이션은 노드 B로 이동할 수 없고 Running -> Pending 상태로 변하게 된다.

그래서 이 Pending 상태를 해결하려면 스케일업을 해서 인스턴스를 프로비저닝하거나
스케일 아웃하여 다시 워커노드의 개수를 증가시켜야 한다.

하지만, EKS에서 노드그룹으로 인스턴스를 배포했다면 스케일업하는 방법은 노드그룹을
지우는 방법밖에 없기 떄문에 스케일 아웃으로 해결해야 한다. 
```

## Helm 
```
쿠버네티스에 배포하는 리소스가 적다면 고민하지 않아도 되지만
배포해야할 양이 많다면 어떨까? 

또 단일 환경이 아니라 dev, stage, prod 라는 환경에 각각 배포해야 한다면
어떨까? 
kubectl create -f 1.yaml
kubectl create -f 2.yaml
kubectl create -f 3.yaml
...
...

이렇게 매 환경마다 명령어를 입력하면 실수가 생길 수 있고 매우 귀찮을 것이다.
그래서 이러한 내용을 한번에 패키징하듯 하나의 명령어로 정의해둔 결과를
한번에 배포하는 것이 Helm 이다.

이 프로젝트에서는 클라이언트 라이브러리 파드를 배포하기 위한 yaml
PV&PVC.yaml , Ingress.yaml , Clusterrole & binding 등을 yaml  
```
## Image Registry
```
dockerhub 프리 계정으로 시간당 제한량 때문에, AWS ECR 로 이미지를 저장했다.
처음엔, 퍼블릭으로 저장했고 그 이미지를 깃헙에 올려두었다.
생각해보니 퍼블릭 이미지는 누구나 액세스할 수 있고, 누군가 의도적으로 접근하면
계정의 비용부담도 올라가고, 노출되길 원치않는 이미지가 노출될 수 있기 때문에
Public -> Private 이미지로 변경하였다. 변경 후, 권한이 없으면 프라이빗 이미지에
접근할 수 없음을 확인했다.

```
